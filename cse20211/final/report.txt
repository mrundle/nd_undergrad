Matt Rundle and Matt Mahan
12/4/12
CSE20211 - Final Project Report

Program Title: Geometry Defense
Description: A simple tower defense game using the gfx library. 


Part 1: The User's Perspective

	The program begins with an introduction, displaying text of our names and the title of the game, before the actual game starts. The game screen consists of a grid with an outlined path, and an information panel to the right. Objects, symbolizing "bad guys," move down the path. Playing the game consists of placing "towers," objects that destroy or slow down the bad guys. If enough bad guys reach the end of the path, the player loses the game, resulting in a game over screen. 

	The top of the information panel has the game title, Geometry Wars, and several pieces of information: money, lives, destroyed, and wave. "Money" is the in-game currency. The player starts with a limited amount of money and gains money for every bad guy destroyed. Placing towers costs money, and a player cannot place towers if they do not have enough money to purchase one. "Lives" is the number of bad guys making it to the end of the path for the player to lose. "Destroyed" is the number of bad guys that have been destroyed by the towers. Lastly,"wave" is a count of how many groups of enemies have appeared. Below this information is a picture of each tower type, each of which is labeled with the name, cost, and button to press in order to place it. Lastly, there is text in the lower right corner of the screen that tells the user they may press p to pause the game and see instructions or press q to exit the game. 

	If the game is paused, the screen is replaced by large text that explain the rules to the player. The player can then press any key to return to the game. In the game, the player must attempt to place towers strategically in order to eliminate all enemies before they reach the end of the path. To place a tower, the player moves their cursor over the desired square, then presses the appropriate key for the desired tower type, either 1, 2, or 3. Towers will not be placed within the path or on top of other towers. The three tower types are Lazer, the cheapest, Slow, and Bomb, the most expensive. Lazer gradually reduces a single enemy's health, Slow reduces the speed of all enemies within its range, and Bomb launches slow-moving bombs that damage all enemies in a small radius around them upon reaching their destination. Good game play strategy requires placing the towers in the best positions and in synergistic combinations. 


Part 2: The Programmer's Perspective

    From the programmers perspective, this program relies on many functions to implement the game logic.  The program contains three main loops: one for the entire game structure (when you lose, it restarts), one for the current game being played (keeps track of levels, towers, etc), and one for each individual level of the game.  

    The program begins by opening a window, and then entering into its first loop. Here, a function is called that displays an “introduction” to the screen, and waits for user input to continue past the introduction.  After this, the program initializes three different arrays of structs. One keeps track of the “bad guys” (mobs) and stores information such as location, velocity, and health.  Another keeps track of the towers, and stores information such as location, range, and cool down time.  The third keeps track of “bombs,” projectiles released from a certain type of tower; it keeps track of bomb location, damage capability, velocity, and direction.  Next, the program initializes many different variables needed to run the game, such as a variable for keeping track of player money, the level of the game, the number of bad guys, and the number of bad guys destroyed.

    After this, the program enters into the second while loop, and the game begins. The current level is incremented and some additional money is given to the player to allow them to place more towers. The program then moves into the third, and final, while loop, and this is where most of the game logic lies.  The program first checks for input from the user; options include quitting, pausing, and adding a tower.  Next, the screen is cleared. Three separate functions are then called to draw the game grid, the game path, and the “bar” separating the game board from the information panel.  After this, a function is called to draw the bad guys on the map, and another is called to draw the towers on the map.

	When this is done, a function is called that draws any “shots” applicable from the towers to the bad guys, and also applies tower effects (such as damage or a slowed velocity) to the bad guys.  To accomplish this, the function loops through all the towers on the board.  For each tower, it loops through the bad guys in order of chronological origin and checks to see if any is in range.  If it finds a bad guy within range, the tower effects are then drawn and applied, and the loop skips to the end of the list of bad guys, and continues to check the next tower.

	The next function called is very similar to the previous one, but it deals with only one type of tower (the one that spits out bombs.)  First, it loops through each tower of this type and subtracts from its cool down timer.  If this timer is zero, a bomb is spawned at the location of that tower, and a destination location is assigned to the new bomb based on the nearest available bad guy (this is accomplished by looping through the bad guys and checking to make sure the distance is within range - if a bad guy is not within range, a bomb will not be spawned.) The cool down timer is then reset.  The function then loops through all bombs on the board, calculates their new positions based on velocity and direction angle, and draws them.  If the bomb has reached its destination, health is subtracted from any bad guy within range and the bomb is deleted.

	Every time a bad guy is deleted (either by losing all health or making it to the end of the path) or a bomb is deleted, a function is called to delete an item from the array.  It loops through the array, starting at the selected element, and deletes it by shifting everything to the left one space and decrementing the variable keeping track of the number of array elements.

	After the shots and bombs have been taken care of, a function loops through each bad guy and calculates its new position along the board path.When this is done, the interface is drawn on the information panel of the screen.  This includes the title of the game, as well as user information such as “Money,” the current “Wave” of bad guys, and the total number of “bad guys” destroyed.  The interface also tells the user which buttons to press to either place a tower or to pause the game and receive instructions. After this is all done, the graphics are flushed to the screen.

	The next bit of code determines when bad guys get spawned.  It checks a clock variable that is incremented each time through the loop: when the timer hits the correct time and there are still bad guys that need to be spawned for that level, a new bad guy of random type is spawned and placed at the beginning of the path.  The number of bad guys created each level is a direct function of that level. The level ends whenever the player has cleared all bad guys from the screen, or if the player loses all of their lives.  If the player loses their lives, the screen will display “Game Over” for a couple of seconds, and then will restart the game from the very first while loop, resetting all of the variables and repeating everything.  Lastly, the program sleeps for .1 seconds, and then returns to check the conditions of the while loop.


Part 3: Verifying the Output

	There are three different ways in which we tested the program and verified output. First, we verify that static images look the way we want them to. We run the program again and again, each time check to see if shapes have the desired size, location, and color. If the program does not look quite right, we change the coordinates and run it again, and repeat this process until the right shapes are rendered in a visually appealing way.

	Second, we test user input. For our program this step is relatively simple, since the only user input is simple key presses. We try each key in the situation in which a certain reaction is supposed to occur, such as the game pausing when p is pressed while the game is running, and modify the program and retest if the correct reaction does not occur. We also test a variety of other keys in each situation, verifying that invalid input does not affect the program in any way.

	Lastly, we needed to test for more complex bugs in the program based on the ways different elements react. To test this, we played the game, but played it carefully. We watched each bad guy and tower, and make sure they move, shoot, die, etc the way they are meant to. We also tested to make sure everything still works properly after a "game over" and if the game advanced to very high waves. This form of testing required the most time, because an exact situation would often need to reproduced to verify a bug existed and then later to verify the problem had been solved. 

